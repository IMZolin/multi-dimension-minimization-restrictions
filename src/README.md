Использование:

1) файл executable.py
2) создаем целевую функцию и ограничения
3) помним, что изначально у ц.ф. и у ограничений K и R выставляются как 10. Если не сходимся, можно поиграть с этими параметрами
4) find_K найдет K в заданном прямоугольнике
5) find_R работает только с одним конкретным примером, так как в неё вписан Гессиан конкретной целевой функции.

Нюансы:

1) Если delta большое, и мы находимся рядом с несколькими границами, то может слуиться, что направления спуска не будет.
2) R, K можно выбрать с запасом, но так будет больше итераций.
3) Если неправильно взять R или K, то мы выйдем за допустимую область, так как именно они регулируют шаг (а шаг не может быть больще, чем позволяет максимальный наклон функций - ограничений).
4) В симплексе -10**-16 < 0 в векторе свободных членов (хотя фактически это 0), и поэтому процесс завершался неправильно (вернее не завершался когда надо). Починил.
5) Симплекс может давать решение s = [0, 0] из-за большого количества, видимо, почти активных ограничений в точке. Это либо конец процесса, либо смещение delta. Наверное.